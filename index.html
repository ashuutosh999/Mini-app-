<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Base Snakes üü¶</title>

<meta name="base:app_id" content="696fa289c0ab25addaaaf7d8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0052FF">

<meta property="og:title" content="Base Snakes üêç" />
<meta property="og:description" content="Play the ultimate crypto snake game on Base!" />
<meta property="og:image" content="https://mini-app-phi-ashen.vercel.app/Gemini_Generated_Image_td1bu1td1bu1td1b.png" />

<meta name="fc:miniapp" content='{
  "version": "1",
  "imageUrl": "https://mini-app-phi-ashen.vercel.app/Gemini_Generated_Image_td1bu1td1bu1td1b.png", 
  "button": {
    "title": "Play Base Snakes",
    "action": {
      "type": "launch_miniapp",
      "name": "Base Snakes",
      "url": "https://mini-app-phi-ashen.vercel.app/", 
      "splashImageUrl": "https://mini-app-phi-ashen.vercel.app/Gemini_Generated_Image_td1bu1td1bu1td1b.png",
      "splashBackgroundColor": "#050510"
    }
  }
}' />

<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Rajdhani:wght@500;700&display=swap');

  :root {
    --base-blue: #0052FF;
    --neon-blue: #00e5ff;
    --neon-pink: #ff00ff;
    --warpcast-purple: #855DCD;
    --bg-dark: #050510;
  }

  html, body {
    overscroll-behavior: none; 
    margin: 0;
    padding: 0;
    height: 100%;
    width: 100%;
    overflow: hidden; 
  }

  body {
    background-color: var(--bg-dark);
    background-image: 
      linear-gradient(rgba(0, 82, 255, 0.1) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0, 82, 255, 0.1) 1px, transparent 1px);
    background-size: 20px 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    color: white;
    font-family: 'Rajdhani', sans-serif;
    touch-action: none; 
  }

  /* Developer Credit */
  .dev-credit {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    font-size: 12px;
    color: #666;
    font-family: 'Rajdhani', sans-serif;
    z-index: 5;
    pointer-events: none;
    letter-spacing: 1px;
  }

  #ui-layer {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10;
  }

  .screen {
    pointer-events: auto;
    background: rgba(0, 0, 0, 0.95);
    border: 2px solid var(--base-blue);
    padding: 24px;
    border-radius: 16px;
    text-align: center;
    backdrop-filter: blur(8px);
    box-shadow: 0 0 25px rgba(0, 82, 255, 0.5);
    width: 85%;
    max-width: 320px;
    display: none;
  }
   
  .screen.active { display: block; }

  h1 { 
    font-family: 'Press Start 2P', cursive; 
    color: var(--base-blue); 
    text-shadow: 2px 2px #fff;
    font-size: 22px;
    margin-bottom: 20px;
    line-height: 1.4;
  }

  input {
    background: #111;
    border: 1px solid var(--base-blue);
    color: white;
    padding: 12px;
    font-size: 16px;
    border-radius: 8px;
    margin-bottom: 15px;
    width: 100%;
    box-sizing: border-box;
    text-align: center;
    font-family: 'Rajdhani', sans-serif;
  }

  button {
    background: var(--base-blue);
    color: white;
    border: none;
    padding: 14px 24px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    transition: transform 0.1s;
    font-family: 'Press Start 2P', cursive;
    width: 100%;
    margin-top: 8px;
    text-transform: uppercase;
  }
   
  button:active { transform: scale(0.95); }
  button:disabled { background: #555; cursor: not-allowed; }

  /* Share Button Styling */
  .btn-share {
    background: var(--warpcast-purple);
    border: 1px solid #fff;
    box-shadow: 0 0 10px var(--warpcast-purple);
    margin-bottom: 10px;
  }

  #hud {
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    width: 100%;
    max-width: 400px;
    padding: 10px;
    box-sizing: border-box;
    font-size: 18px;
    font-weight: bold;
    text-shadow: 0 0 5px var(--neon-blue);
    margin-top: 25px; 
  }

  .hud-left { text-align: left; }
  .hud-right { text-align: right; }

  canvas {
    background: rgba(0,0,0,0.8);
    border: 2px solid var(--base-blue);
    border-radius: 12px;
    box-shadow: 0 0 15px var(--base-blue);
    display: block;
  }

  .leaderboard-container {
    margin-top: 15px;
    width: 90%;
    max-width: 350px;
    background: rgba(0,0,0,0.6);
    border: 1px solid #333;
    border-radius: 8px;
    padding: 10px;
    max-height: 150px;
    overflow-y: auto;
    font-size: 14px;
  }
   
  .lb-row {
    display: flex;
    justify-content: space-between;
    padding: 4px 0;
    border-bottom: 1px solid #222;
  }
  .lb-rank { color: var(--neon-pink); font-weight: bold; }
  .lb-name { color: white; }
  .lb-score { color: var(--neon-blue); }

  .mobile-hint {
    margin-top: 10px;
    color: #666;
    font-size: 12px;
    display: none;
  }
  @media (hover: none) {
    .mobile-hint { display: block; }
  }
   
  #finalScore {
    font-size: 32px;
    color: var(--neon-blue);
    font-weight: bold;
    text-shadow: 0 0 10px var(--neon-blue);
  }

</style>
</head>
<body>

  <div class="dev-credit">developed by - @ashutosh9</div>

  <div id="hud">
    <div class="hud-left">
      <div id="scoreDisplay">SCORE: 0</div>
      <div id="bestScoreDisplay" style="font-size: 14px; color: var(--neon-pink);">BEST: -</div>
    </div>
    <div class="hud-right">
       <div id="walletDisplay" style="font-size:12px; opacity:0.7; font-family:'Courier New', monospace;"></div>
       <div id="usernameDisplay" style="font-size:12px; color:var(--neon-blue); font-weight:bold;"></div>
    </div>
  </div>

  <canvas id="game"></canvas>

  <div class="mobile-hint">üëÜ Swipe to turn ‚Ä¢ Tap to speed up</div>

  <div class="leaderboard-container">
    <div style="text-align:center; color: var(--base-blue); font-weight:bold; margin-bottom:5px;">üèÜ MONTHLY LEADERS</div>
    <div id="leaderboardList">Connect wallet to view</div>
  </div>

  <div id="ui-layer">
    
    <div id="screen-loading" class="screen active">
      <h1 style="font-size:16px;">LOADING...</h1>
    </div>

    <div id="screen-register" class="screen">
      <h1>BASE SNAKES</h1>
      <p style="font-size:14px; color:#aaa; margin-bottom:15px;">Enter username to play</p>
      <input type="text" id="usernameInput" placeholder="CryptoSnake123" maxlength="12">
      <br>
      <button onclick="setLocalNameAndPlay()">PLAY NOW</button>
      <div style="margin-top:10px; font-size:10px; color:#666;">Works with Warpcast, Rainbow, MetaMask</div>
    </div>

    <div id="screen-start" class="screen">
      <h1 id="welcomeMsg">WELCOME</h1>
      <p style="margin-bottom:20px;">Ready to eat?</p>
      <button onclick="unlockAudioAndStart()">‚ñ∂ START GAME</button>
    </div>

    <div id="screen-gameover" class="screen">
      <h1 style="color:var(--neon-pink)">GAME OVER</h1>
      <p>Score: <span id="finalScore">0</span></p>
       
      <button class="btn-share" onclick="shareScore()">üì§ SHARE ON FARCASTER</button>
       
      <button id="btnSave" onclick="handleChainSave()">üíæ SAVE ON-CHAIN</button>
       
      <button onclick="unlockAudioAndStart()">üîÑ RESTART</button>
    </div>

  </div>

<script type="module">
  import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
  window.sdk = sdk; 
  sdk.actions.ready();
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>

<script>
// Global Vars
let provider, signer, contract;
let userAddress, currentUsername;
const CONTRACT_ADDRESS = "0x1A7CcE659Ad0f71Ddc9f2Af9f4d1F155A8291BDd"; 

// --- INIT: Auto Check Wallet on Load ---
window.addEventListener('load', async () => {
    // Small delay to ensure injections are ready
    setTimeout(initApp, 500);
});

async function initApp() {
    // Try to find a provider immediately
    const ethProvider = await getWalletProvider();
    
    if (ethProvider) {
        // Attempt silent connection
        try {
            provider = new ethers.providers.Web3Provider(ethProvider);
            // Just get accounts, don't force popup if already authorized
            const accounts = await provider.listAccounts();
            
            if (accounts.length > 0) {
                // Wallet already connected/authorized!
                await setupWeb3(false); // False = don't prompt
            } else {
                // Wallet found but not connected, show Register Screen
                showScreen('screen-register');
            }
        } catch (e) {
            console.log("Auto-connect failed", e);
            showScreen('screen-register');
        }
    } else {
        // No wallet, just show register
        showScreen('screen-register');
    }
}

// 1. Local Login (Fallback or First Time)
async function setLocalNameAndPlay() {
    const name = document.getElementById("usernameInput").value.trim();
    if (!name || name.length > 12) return alert("Invalid Name (1-12 chars)");
    
    currentUsername = name;
    
    // If we have a wallet but didn't connect yet, try connecting now
    // This allows us to check registration before they start playing
    if (!contract) {
        const success = await setupWeb3(true); // True = force popup
        if (success) {
            // If setupWeb3 succeeds, it will handle screen transition
            return; 
        }
    }

    // Fallback: Local play only
    document.getElementById("welcomeMsg").innerText = `HI, ${currentUsername.toUpperCase()}`;
    showScreen('screen-start');
}

// 2. Setup Web3 & Check Registration
async function setupWeb3(forcePrompt = true) {
    try {
        const ethProvider = await getWalletProvider();
        if (!ethProvider) return false;

        provider = new ethers.providers.Web3Provider(ethProvider);
        
        if (forcePrompt) {
            await provider.send("eth_requestAccounts", []);
        }

        const network = await provider.getNetwork();
        if (network.chainId !== 8453 && network.chainId !== 84532) {
             if (forcePrompt) alert("Please switch to Base Network!");
             return false;
        }

        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);
        
        // UI Updates
        document.getElementById("walletDisplay").innerText = `üü¢ ${userAddress.slice(0,4)}...${userAddress.slice(-4)}`;
        
        // CHECK IF REGISTERED
        const player = await contract.getPlayer(userAddress);
        const onChainName = player[0];
        const bestScore = player[1] ? player[1].toNumber() : 0;

        if (onChainName && onChainName !== "") {
            // USER EXISTS: Auto-Login
            currentUsername = onChainName;
            document.getElementById("bestScoreDisplay").innerText = `BEST: ${bestScore}`;
            document.getElementById("usernameDisplay").innerText = currentUsername;
            document.getElementById("welcomeMsg").innerText = `WB, ${currentUsername.toUpperCase()}`;
            showScreen('screen-start');
        } else {
            // NEW USER: Stay on Register screen (or go there if not already)
            // If we came from setLocalNameAndPlay, we have a name, so we can proceed
            if (currentUsername) {
                document.getElementById("welcomeMsg").innerText = `HI, ${currentUsername.toUpperCase()}`;
                showScreen('screen-start');
            } else {
                showScreen('screen-register');
            }
        }

        // Initial Data Fetch
        fetchLeaderboard();
        return true;

    } catch (e) {
        console.error("Setup Web3 failed", e);
        return false;
    }
}

// 3. Save Score Logic
async function handleChainSave() {
    const btn = document.getElementById('btnSave');
    
    if (!contract) {
        btn.innerText = "CONNECTING...";
        const connected = await setupWeb3(true);
        if (!connected) {
            btn.innerText = "üíæ SAVE ON-CHAIN";
            return; 
        }
    }

    btn.disabled = true;

    try {
        btn.innerText = "CHECKING REG...";
        const player = await contract.getPlayer(userAddress);
        const registeredName = player[0];

        // If not registered, register now
        if (!registeredName) {
            btn.innerText = "REGISTERING...";
            // Use the name they played with
            if(!currentUsername) currentUsername = "SnakePlayer";
            const txReg = await contract.registerUser(currentUsername);
            await txReg.wait();
        }

        // Save Score
        btn.innerText = "SIGNING SCORE...";
        const txScore = await contract.saveScore(score);
        
        btn.innerText = "MINING...";
        await txScore.wait();
        
        btn.innerText = "SAVED! ‚úÖ";
        
        // Refresh Data
        const p = await contract.getPlayer(userAddress);
        document.getElementById("bestScoreDisplay").innerText = `BEST: ${p[1].toNumber()}`;
        fetchLeaderboard();

    } catch (err) {
        console.error(err);
        alert("Transaction failed: " + (err.reason || err.message));
        btn.disabled = false;
        btn.innerText = "üíæ SAVE ON-CHAIN";
    }
}

// Helper: Provider Detection
async function getWalletProvider() {
    if (window.sdk && window.sdk.provider) return window.sdk.provider;
    if (window.ethereum) {
        if (window.ethereum.providers) {
             const found = window.ethereum.providers.find(p => p.isRainbow || p.isCoinbaseWallet);
             return found || window.ethereum.providers[0];
        }
        return window.ethereum;
    }
    return null;
}

// --- AUDIO MANAGER ---
const audioFiles = {
    bgm: 'music.mp3',
    eat: 'eat.mp3',
    powerup: 'powerup.mp3',
    gameover: 'gameover.mp3'
};
const sounds = {};
Object.keys(audioFiles).forEach(key => {
    sounds[key] = new Audio(audioFiles[key]);
});
sounds.bgm.loop = true; 
sounds.bgm.volume = 0.4;

function unlockAudioAndStart() {
    Object.values(sounds).forEach(snd => {
        if(snd.paused) {
            snd.muted = true;
            snd.play().catch(e => {}); 
            snd.pause();
            snd.currentTime = 0;
            snd.muted = false; 
        }
    });
    sounds.bgm.currentTime = 0;
    sounds.bgm.play().catch(e => console.log("BGM Start blocked", e));
    startGame();
}

function playSound(name) {
    if (!sounds[name]) return;
    if (name !== 'bgm') {
        sounds[name].pause();
        sounds[name].currentTime = 0;
        sounds[name].volume = 0.8; 
        sounds[name].play().catch(e => {});
    }
}

function stopMusic() {
    sounds.bgm.pause();
    sounds.bgm.currentTime = 0;
}

function shareScore() {
    const appUrl = "https://mini-app-phi-ashen.vercel.app/"; 
    const text = `I just scored ${score} on Base Snakes! üêç\n\nCan you beat me? Play now on @base üëá`;
    const intentUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(text)}&embeds[]=${encodeURIComponent(appUrl)}`;

    if (window.sdk && window.sdk.actions && window.sdk.actions.openUrl) {
        window.sdk.actions.openUrl(intentUrl);
    } else {
        window.open(intentUrl, '_blank');
    }
}

// --- LEADERBOARD (CHUNKED FETCH) ---
async function fetchLeaderboard() {
    if (!contract) return;
    
    const list = document.getElementById("leaderboardList");
    // Don't clear immediately, looks glitchy. Just update when ready.
    
    try {
        const currentBlock = await provider.getBlockNumber();
        const currentMonth = new Date().getMonth();
        let scores = [];
        
        // CHUNKING CONFIG
        const BLOCK_CHUNK = 10000; // 10k blocks per request (safe for free RPCs)
        const MAX_LOOKBACK = 100000; // Look back ~5-6 days (or adjust as needed)
        
        let toBlock = currentBlock;
        let fromBlock = Math.max(0, currentBlock - BLOCK_CHUNK);
        
        // Loop backwards until we reach limit
        while (toBlock > currentBlock - MAX_LOOKBACK && fromBlock >= 0) {
            const filter = contract.filters.NewScore();
            const events = await contract.queryFilter(filter, fromBlock, toBlock);
            
            for (let e of events) {
                // Check month locally to avoid fetching block timestamp for every event
                // This is an estimation. For strict month accuracy, you need block.timestamp
                // For a mini-app, just showing recent high scores is usually enough.
                // We'll trust the event order (newest first).
                
                // Simple dedup: check if username already in list
                // If you want "Highest per user", check logic here.
                // If you want "All High Scores", just push.
                scores.push({
                    name: e.args.username,
                    score: e.args.score.toNumber()
                });
            }

            // Optimization: If we have enough scores (e.g., 20+), we can stop early
            if (scores.length > 50) break;

            toBlock = fromBlock - 1;
            fromBlock = Math.max(0, toBlock - BLOCK_CHUNK);
        }

        // Sort descending
        scores.sort((a,b) => b.score - a.score);
        
        // Unique names only (Top score per user)
        const uniqueScores = [];
        const seenNames = new Set();
        for (let s of scores) {
            if (!seenNames.has(s.name)) {
                uniqueScores.push(s);
                seenNames.add(s.name);
            }
        }

        const top5 = uniqueScores.slice(0, 5);

        if(top5.length === 0) {
            list.innerHTML = "<div style='text-align:center; padding:10px;'>No scores found recently!</div>";
        } else {
            list.innerHTML = top5.map((s, i) => `
                <div class="lb-row">
                    <span class="lb-rank">#${i+1}</span>
                    <span class="lb-name">${s.name}</span>
                    <span class="lb-score">${s.score}</span>
                </div>
            `).join('');
        }
    } catch(e) {
        console.log("Error loading leaderboard", e);
        list.innerHTML = "<div style='text-align:center; padding:10px; color:red;'>Error loading scores</div>";
    }
}

// --- WEB3 ABI ---
const ABI = [
  "function registerUser(string username) public",
  "function saveScore(uint256 score) public",
  "function getPlayer(address _addr) public view returns (string, uint256)",
  "event NewScore(address indexed player, string username, uint256 score, uint256 timestamp)",
  "event UserRegistered(address indexed player, string username)"
];

// --- GAME ENGINE ---
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const box = 20; 

const setCanvasSize = () => {
    let size = Math.min(window.innerWidth - 20, 400);
    size = Math.floor(size / box) * box; 
    canvas.width = size;
    canvas.height = size;
};
setCanvasSize();
window.addEventListener('resize', setCanvasSize);

let snake, dir, food, score, gameLoop;
let isPlaying = false;
let inputQueue = [];
let gameSpeed = 130; 
let activePowerUp = null; 
let growthPending = 0;    
let powerUpTimer = null;  

function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
}

function animateScore(targetScore) {
    const scoreElement = document.getElementById("finalScore");
    let current = 0;
    const duration = 1000;
    const startTime = performance.now();
    function update(time) {
        const elapsed = time - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const ease = 1 - Math.pow(1 - progress, 3);
        current = Math.floor(ease * targetScore);
        scoreElement.innerText = current;
        if (progress < 1) requestAnimationFrame(update);
        else scoreElement.innerText = targetScore;
    }
    requestAnimationFrame(update);
}

function startGame() {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    snake = [{ x: 10 * box, y: 10 * box }];
    dir = "RIGHT";
    inputQueue = []; 
    score = 0;
    gameSpeed = 130; 
    activePowerUp = null;
    growthPending = 0;

    document.getElementById("scoreDisplay").innerText = "SCORE: 0";
    placeFood();
    scheduleNextPowerUp(); 
    isPlaying = true;
    if (gameLoop) clearInterval(gameLoop);
    gameLoop = setInterval(draw, gameSpeed);
}

function scheduleNextPowerUp() {
    if (powerUpTimer) clearTimeout(powerUpTimer);
    const delay = Math.random() * 10000 + 5000;
    powerUpTimer = setTimeout(() => {
        if (!isPlaying) return;
        spawnPowerUp();
    }, delay);
}

function spawnPowerUp() {
    const cols = Math.floor(canvas.width / box);
    const rows = Math.floor(canvas.height / box);
    let newItem = {
        x: Math.floor(Math.random() * cols) * box,
        y: Math.floor(Math.random() * rows) * box,
        type: Math.random() > 0.5 ? 'HALF' : 'DOUBLE', 
        expireTime: Date.now() + 5000 
    };
    if (collision(newItem.x, newItem.y, snake) || (newItem.x === food.x && newItem.y === food.y)) {
        spawnPowerUp(); 
        return;
    }
    activePowerUp = newItem;
    setTimeout(() => {
        if (activePowerUp && activePowerUp === newItem) {
            activePowerUp = null;
        }
    }, 5000);
    scheduleNextPowerUp();
}

function placeFood() {
    const cols = Math.floor(canvas.width / box);
    const rows = Math.floor(canvas.height / box);
    food = {
        x: Math.floor(Math.random() * cols) * box,
        y: Math.floor(Math.random() * rows) * box
    };
}

function increaseSpeed() {
    if (gameSpeed > 60) { 
        gameSpeed -= 5; 
        clearInterval(gameLoop);
        gameLoop = setInterval(draw, gameSpeed);
    }
}

function draw() {
    if (inputQueue.length > 0) {
        let next = inputQueue.shift();
        if (next === "LEFT" && dir !== "RIGHT") dir = "LEFT";
        else if (next === "UP" && dir !== "DOWN") dir = "UP";
        else if (next === "RIGHT" && dir !== "LEFT") dir = "RIGHT";
        else if (next === "DOWN" && dir !== "UP") dir = "DOWN";
    }

    ctx.fillStyle = "rgba(5, 5, 16, 0.6)"; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.shadowBlur = 15;
    ctx.shadowColor = "#ff00ff";
    ctx.fillStyle = "#ff00ff";
    ctx.fillRect(food.x, food.y, box-2, box-2);
    ctx.shadowBlur = 0;

    if (activePowerUp) {
        if (Date.now() > activePowerUp.expireTime) {
            activePowerUp = null;
        } else {
            const isDouble = activePowerUp.type === 'DOUBLE';
            ctx.shadowBlur = 20;
            ctx.shadowColor = isDouble ? "#00ff00" : "#ff0000"; 
            ctx.fillStyle = isDouble ? "#00ff00" : "#ff0000";
            
            ctx.beginPath();
            ctx.arc(activePowerUp.x + box/2, activePowerUp.y + box/2, box/2, 0, 2 * Math.PI);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = "white";
            ctx.font = "10px Arial";
            ctx.textAlign = "center";
            ctx.fillText(isDouble ? "2x" : "¬Ω", activePowerUp.x + box/2, activePowerUp.y + box - 4);
        }
    }

    for (let i = 0; i < snake.length; i++) {
        ctx.fillStyle = (i === 0) ? "#ffffff" : "#0052FF"; 
        ctx.shadowBlur = (i === 0) ? 10 : 0;
        ctx.shadowColor = "#ffffff";
        ctx.fillRect(snake[i].x, snake[i].y, box-2, box-2);
        ctx.shadowBlur = 0;
    }

    let snakeX = snake[0].x;
    let snakeY = snake[0].y;

    if (dir === "LEFT") snakeX -= box;
    if (dir === "UP") snakeY -= box;
    if (dir === "RIGHT") snakeX += box;
    if (dir === "DOWN") snakeY += box;

    if (snakeX < 0) snakeX = canvas.width - box;
    else if (snakeX >= canvas.width) snakeX = 0;
    
    if (snakeY < 0) snakeY = canvas.height - box;
    else if (snakeY >= canvas.height) snakeY = 0;

    if (collision(snakeX, snakeY, snake)) {
        gameOver();
        return;
    }

    let ateFood = false;
    if (snakeX === food.x && snakeY === food.y) {
        score++;
        document.getElementById("scoreDisplay").innerText = "SCORE: " + score;
        playSound('eat'); 
        placeFood();
        ateFood = true;
        if (score % 5 === 0) {
            increaseSpeed();
        }
    }

    if (activePowerUp && snakeX === activePowerUp.x && snakeY === activePowerUp.y) {
        playSound('powerup'); 
        if (activePowerUp.type === 'HALF') {
            const newLen = Math.max(1, Math.floor(snake.length / 2));
            snake = snake.slice(0, newLen);
            score = Math.floor(score / 2);
        } else if (activePowerUp.type === 'DOUBLE') {
            growthPending += snake.length;
            score = score * 2;
        }
        document.getElementById("scoreDisplay").innerText = "SCORE: " + score;
        activePowerUp = null;
        if (score % 5 === 0 && score > 0) {
             increaseSpeed();
        }
    }

    if (ateFood) {
    } else if (growthPending > 0) {
        growthPending--;
    } else {
        snake.pop();
    }

    let newHead = { x: snakeX, y: snakeY };
    snake.unshift(newHead);
}

function collision(x, y, array) {
    for (let i = 0; i < array.length; i++) {
        if (x === array[i].x && y === array[i].y) return true;
    }
    return false;
}

function gameOver() {
    isPlaying = false;
    clearInterval(gameLoop);
    if(powerUpTimer) clearTimeout(powerUpTimer);
    stopMusic(); 
    playSound('gameover'); 
    showScreen('screen-gameover');
    animateScore(score);
    const btn = document.getElementById('btnSave');
    btn.disabled = false;
    btn.innerText = "üíæ SAVE ON-CHAIN";
}

document.addEventListener("keydown", function(event) {
    const key = event.keyCode;
    if (key == 37 || key == 65) inputQueue.push("LEFT");
    else if (key == 38 || key == 87) inputQueue.push("UP");
    else if (key == 39 || key == 68) inputQueue.push("RIGHT");
    else if (key == 40 || key == 83) inputQueue.push("DOWN");
});

let touchStartX = 0;
let touchStartY = 0;

document.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
document.addEventListener('touchstart', function(event) {
    touchStartX = event.changedTouches[0].screenX;
    touchStartY = event.changedTouches[0].screenY;
}, false);
document.addEventListener('touchend', function(event) {
    let touchEndX = event.changedTouches[0].screenX;
    let touchEndY = event.changedTouches[0].screenY;
    handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
}, false);

function handleSwipe(startX, startY, endX, endY) {
    let xDiff = endX - startX;
    let yDiff = endY - startY;

    if (Math.abs(xDiff) > Math.abs(yDiff)) {
        if (xDiff > 0) inputQueue.push("RIGHT");
        else if (xDiff < 0) inputQueue.push("LEFT");
    } else {
        if (yDiff > 0) inputQueue.push("DOWN");
        else if (yDiff < 0) inputQueue.push("UP");
    }
}
</script>
</body>
</html>
